#混淆插件说明#

从3.5.1版本起有一个新的实验性TCP连接下的混淆接口，在原来的协议外套一层编码和解码接口，不但可以伪装成其它协议流量（但目前接口功能还没有写完，目前还在测试完善中），还可以把原协议转换为其它协议进行兼容或完善，需要服务端与客户端配置相同的混淆插件。以下为各插件的介绍：

* plain：表示不混淆，使用原协议

* http_simple：并非完全按照http1.1标准实现，仅仅做了一个头部的GET请求和一个简单的回应，之后依然为原协议流。使用这个混淆后，已在部分地区观察到似乎欺骗了QOS的结果。对于这种混淆，它并非为了减少特征，相反的是提供一种强特征，试图欺骗GFW的协议检测。要注意的是应用范围变大以后因特征明显有可能会被封锁。此插件可以兼容原协议(需要在服务端配置为http_simple_compatible)，延迟与原协议几乎无异（在存在QOS的地区甚至可能更快），除了头部数据包外没有冗余数据包。

* tls_simple：模拟https/TLS1.2的握手过程，目前未完成，server hello的应答数据不完整，但亦可使用。此插件可以兼容原协议(需要在服务端配置为tls_simple_compatible)，比原协议多一次握手导致连接时间会长一些，除了握手过程之后没有冗余数据包。

* random_head：开始通讯前发送一个几乎为随机的数据包（目前末尾4字节为CRC32，会成为特征，以后会改进），之后为原协议流。目标是让首个数据包根本不存在任何有效信息，让统计学习机制见鬼去吧。此插件可以兼容原协议(需要在服务端配置为random_head_compatible)，比原协议多一次握手导致连接时间会长一些，除了握手过程之后没有冗余数据包。

* verify_simple：对每一个包都进行CRC32验证和长度混淆，数据格式为：包长度(2字节)|随机数据长度+1(1字节)|随机数据|原数据包|CRC32，此混淆插件可完全替代之前版本制作的协议。此插件不兼容原协议，与原协议握手延迟相同，整个通讯过程中存在验证及混淆用的冗余数据包，下载的情况下冗余数据平均占比2%，普通浏览时占比略高一些，但平均也不会超过10%（）。（左边萌萌的空括号其实只是避免百分号和句号在一起误解为千分号而已）

* verify_deflate：对每一个包都进行deflate压缩(zlib/Gzip)，数据格式为：包长度(2字节)|压缩数据流|原数据流Alder-32，此格式省略了0x78,0x9C两字节的头部。另外，对于已经压缩过或加密过的数据将难以压缩（可能增加1~20字节），而对于未加密的html文本会有不错的压缩效果。因为压缩及解压缩较占CPU，不建议较多用户同时使用此混淆插件。

这样以来，将来只要简单的换一个混淆插件，让大家的特征各不相同，GFW就极难下手统一封锁了。

#混淆配置方法：#
* 服务端配置：使用最新SSR的manyuser分支，config.json里有一个obfs的字段，目前的可能取值为：plain, http_simple, http_simple_compatible, tls_simple, tls_simple_compatible, random_head, random_head_compatible, verify_simple, verify_deflate。

默认为"obfs":"http_simple_compatible",
服务端配置为xxabc_compatible时（以compatible为后缀的），即服务端支持使用原版客户端，或使用配置插件为xxabc或plain的ssr客户端。

* 客户端配置：使用本ssr版本，在编辑服务器配置里找到相应节点，最后在obfs选项的列表里选择需要使用的插件即可
